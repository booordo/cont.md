"use strict";

function _instanceof(left, right) {
  if (
    right != null &&
    typeof Symbol !== "undefined" &&
    right[Symbol.hasInstance]
  ) {
    return right[Symbol.hasInstance](left);
  } else {
    return left instanceof right;
  }
}

function _classCallCheck(instance, Constructor) {
  if (!_instanceof(instance, Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

(function() {
  var Puzzle =
    /*#__PURE__*/
    (function() {
      function Puzzle(context, cx, cy, elements) {
        _classCallCheck(this, Puzzle);

        this.context = context;
        this.maxContextWidth = 1140;
        this.contextWidth = 1140;
        this.contextHeight = 800;
        this.cx = cx;
        this.cy = cy;
        this.elements = elements;
        this.sectorAngle = 360 / elements.length;
        this.innerRadius = 150;
        this.outerRadius = 330;
        this.padding = 15;
        this.width = this.outerRadius * 2 + this.padding;
        this.middleRadius =
          this.innerRadius + (this.outerRadius - this.innerRadius) / 2;
        this.connectorCurveAngle = 50;
        this.connectorCurveLength = 40;
        this.connectorWidth = 25;
        this.connectorStart = this.middleRadius + this.connectorWidth / 2;
        this.connectorEnd = this.middleRadius - this.connectorWidth / 2;
        this.mainGroup = this.context.g();
        this.circlePath = [];

        this._updatePuzzle();

        this._updateSize();

        this._setEventHandlers();
      } // SECTORS

      _createClass(Puzzle, [
        {
          key: "_updatePuzzle",
          value: function _updatePuzzle() {
            this.context.clear();
            this.circlePath = [];
            this.mainGroup = this.context.g();

            this._createSectors();

            this.mainGroup.add(this._createCircle());
          }
        },
        {
          key: "_updateSize",
          value: function _updateSize() {
            var clientWidth = document.body.clientWidth;
            var k = (clientWidth - 30) / this.width;
            var offsetX = -(this.contextWidth - clientWidth) / 2;
            offsetX = offsetX > 0 ? 0 : offsetX;
            var offsetY = -(this.contextHeight - this.contextHeight * k) / 2;
            offsetY = offsetY > 0 ? 0 : offsetY;

            if (clientWidth < this.width) {
              this.mainGroup.transform(
                "T "
                  .concat(offsetX, ", ")
                  .concat(offsetY, " s")
                  .concat(k)
              );
              this.context.attr({
                style: "height: ".concat(this.contextHeight * k, "px")
              });
            } else {
              this.mainGroup.transform(
                "T ".concat(offsetX, ", ").concat(offsetY)
              );
              this.context.attr({
                style: "height: 800px"
              });
            }
          }
        },
        {
          key: "_createSectors",
          value: function _createSectors() {
            var _this = this;

            elements.forEach(function(el, i) {
              var fromAngle = i * _this.sectorAngle;
              var toAngle = fromAngle + _this.sectorAngle;

              _this.mainGroup.add(_this._createSector(fromAngle, toAngle, el));
            });
          }
        },
        {
          key: "_createCircle",
          value: function _createCircle() {
            var path = "";
            this.circlePath.forEach(function(el, i) {
              path += el + " ";
            });
            var circle = this.context.path(path).attr({
              fill: "#2A2A2B",
              stroke: "#fff",
              strokeWidth: "3px"
            });
            var circleBBox = circle.getBBox();
            var title = this.context
              .text(
                circleBBox.x + circleBBox.width / 2,
                circleBBox.y + circleBBox.height / 2,
                "ERP"
              )
              .attr({
                class: "puzzle__circle-title",
                fill: "#fff"
              });
            var textBBox = title.getBBox();
            title.transform("T 0 ".concat(this.cy - textBBox.cy));
            var topText = this.context
              .text(
                textBBox.cx,
                this.cy - textBBox.height / 2 + 10,
                "Contabilizare 4.0"
              )
              .attr({
                class: "puzzle__circle-choice",
                fill: "#f1c40f"
              });
            var bottomText = this.context
              .text(textBBox.cx, this.cy + textBBox.height / 2, "Система")
              .attr({
                class: "puzzle__circle-subtitle",
                textLength: "185",
                fill: "#fff"
              });
            var bottomTextBBox = bottomText.getBBox(); // IE FIX -->

            bottomText.transform(
              "T ".concat(this.cx - bottomTextBBox.cx, " 0")
            ); // IE FIX <--

            var group = this.context.g(circle, title, topText, bottomText);
            group.hover(
              this._circleHoverInHandler,
              this._circleHoverOutHandler,
              group,
              group
            );
            group.click(function(e) {
              document.location.href = "/contabilizare-4-0/erp-system/";
            });
            return group;
          }
        },
        {
          key: "_createSector",
          value: function _createSector(fromAngle, toAngle, element) {
            var _this2 = this;

            var middleAngle = (fromAngle + toAngle) / 2;

            var oArcPts = this._getArcPoints(
              this.outerRadius,
              fromAngle,
              toAngle
            );

            var iArcPts = this._getArcPoints(
              this.innerRadius,
              fromAngle,
              toAngle
            );

            var oConPts = this._getConnectorPoints(toAngle);

            var iConPts = this._getConnectorPoints(fromAngle);

            var cConPts = this._getCircleConnectorPoints(middleAngle);

            var group = this.context.g();
            var sector = this.context
              .path(
                "M "
                  .concat(oArcPts.start.x, " ")
                  .concat(oArcPts.start.y, "\n            A ")
                  .concat(this.outerRadius, " ")
                  .concat(this.outerRadius, " 0 0 1 ")
                  .concat(oArcPts.end.x, " ")
                  .concat(oArcPts.end.y, "\n            L ")
                  .concat(oConPts.start.x, " ")
                  .concat(oConPts.start.y, "\n            C ")
                  .concat(oConPts.guides.start.x, " ")
                  .concat(oConPts.guides.start.y, " ")
                  .concat(oConPts.guides.end.x, " ")
                  .concat(oConPts.guides.end.y, " ")
                  .concat(oConPts.end.x, " ")
                  .concat(oConPts.end.y, "\n            L ")
                  .concat(iArcPts.end.x, " ")
                  .concat(iArcPts.end.y, "\n            A ")
                  .concat(this.innerRadius, " ")
                  .concat(this.innerRadius, " 0 0 0 ")
                  .concat(cConPts.end.x, " ")
                  .concat(cConPts.end.y, "\n            C ")
                  .concat(cConPts.guides.end.x, " ")
                  .concat(cConPts.guides.end.y, " ")
                  .concat(cConPts.guides.start.x, " ")
                  .concat(cConPts.guides.start.y, " ")
                  .concat(cConPts.start.x, " ")
                  .concat(cConPts.start.y, "\n            A ")
                  .concat(this.innerRadius, " ")
                  .concat(this.innerRadius, " 0 0 0 ")
                  .concat(iArcPts.start.x, " ")
                  .concat(iArcPts.start.y, "\n            L ")
                  .concat(iConPts.end.x, " ")
                  .concat(iConPts.end.y, "\n            C ")
                  .concat(iConPts.guides.end.x, " ")
                  .concat(iConPts.guides.end.y, " ")
                  .concat(iConPts.guides.start.x, " ")
                  .concat(iConPts.guides.start.y, " ")
                  .concat(iConPts.start.x, " ")
                  .concat(iConPts.start.y, "\n            Z")
              )
              .attr({
                fill: "rgba(255,255,255,0.4)",
                stroke: "#fff",
                strokeWidth: "3px",
                class: "puzzle__sector"
              });
            this.circlePath.unshift(
              "A "
                .concat(this.innerRadius, " ")
                .concat(this.innerRadius, " 0 0 0 ")
                .concat(cConPts.end.x, " ")
                .concat(cConPts.end.y, "\n            C ")
                .concat(cConPts.guides.end.x, " ")
                .concat(cConPts.guides.end.y, " ")
                .concat(cConPts.guides.start.x, " ")
                .concat(cConPts.guides.start.y, " ")
                .concat(cConPts.start.x, " ")
                .concat(cConPts.start.y, "\n            A ")
                .concat(this.innerRadius, " ")
                .concat(this.innerRadius, " 0 0 0 ")
                .concat(iArcPts.start.x, " ")
                .concat(iArcPts.start.y)
            );

            if (this.elements.indexOf(element) == this.elements.length - 1) {
              this.circlePath.unshift(
                "M ".concat(iArcPts.end.x, " ").concat(iArcPts.end.y)
              );
            }

            group.add(sector);
            element.title.forEach(function(el, i) {
              var textStartPoint = _this2._getPoint(
                _this2.cx,
                _this2.cy,
                _this2.middleRadius - (middleAngle > 180 ? i * 20 : -i * 20),
                fromAngle
              );

              var textEndPoint = _this2._getPoint(
                _this2.cx,
                _this2.cy,
                _this2.middleRadius - (middleAngle > 180 ? i * 20 : -i * 20),
                toAngle
              );

              var text = _this2.context.text(0, 0, el).attr({
                class: "puzzle__text",
                textpath: "M "
                  .concat(
                    middleAngle > 180
                      ? textStartPoint.x + " " + textStartPoint.y
                      : textEndPoint.x + " " + textEndPoint.y,
                    " \n                A "
                  )
                  .concat(_this2.middleRadius, " ")
                  .concat(_this2.middleRadius, " 0 0 ")
                  .concat(middleAngle < 180 ? 0 : 1, " ")
                  .concat(
                    middleAngle > 180
                      ? textEndPoint.x + " " + textEndPoint.y
                      : textStartPoint.x + " " + textStartPoint.y
                  )
              });

              text.textPath.attr({
                "text-anchor": "middle",
                startOffset: "50%"
              }); // IE FIX -->

              text.node.removeAttribute("x");
              text.node.removeAttribute("y"); // IE FIX <--

              group.add(text);
            });
            group.hover(
              this._sectorHoverInHandler,
              this._sectorHoverOutHandler,
              group,
              group
            );
            group.click(function(e) {
              document.location.href = element.link;
            });
            return group;
          }
        },
        {
          key: "_getArcPoints",
          value: function _getArcPoints(radius, fromAngle, toAngle) {
            return {
              start: this._getPoint(this.cx, this.cy, radius, fromAngle),
              end: this._getPoint(this.cx, this.cy, radius, toAngle)
            };
          }
        },
        {
          key: "_getConnectorPoints",
          value: function _getConnectorPoints(angle) {
            var start = this._getPoint(
              this.cx,
              this.cy,
              this.connectorStart,
              angle
            );

            var end = this._getPoint(
              this.cx,
              this.cy,
              this.connectorEnd,
              angle
            );

            return {
              start: start,
              end: end,
              guides: this._getConnectorGuidesPoints(start, end, angle)
            };
          }
        },
        {
          key: "_getCircleConnectorPoints",
          value: function _getCircleConnectorPoints(angle) {
            var offset = this._getAngleByArcLength(
              this.connectorWidth / 2,
              this.innerRadius
            );

            var start = this._getPoint(
              this.cx,
              this.cy,
              this.innerRadius,
              angle - offset
            );

            var end = this._getPoint(
              this.cx,
              this.cy,
              this.innerRadius,
              angle + offset
            );

            return {
              start: start,
              end: end,
              guides: this._getConnectorGuidesPoints(start, end, angle - 90)
            };
          }
        },
        {
          key: "_getConnectorGuidesPoints",
          value: function _getConnectorGuidesPoints(start, end, angle) {
            return {
              start: this._getPoint(
                start.x,
                start.y,
                this.connectorCurveLength,
                angle + this.connectorCurveAngle
              ),
              end: this._getPoint(
                end.x,
                end.y,
                this.connectorCurveLength,
                angle + 180 - this.connectorCurveAngle
              )
            };
          }
        },
        {
          key: "_getPoint",
          value: function _getPoint(cx, cy, radius, angle) {
            return {
              x: cx + radius * Math.cos((angle * Math.PI) / 180),
              y: cy + radius * Math.sin((angle * Math.PI) / 180)
            };
          }
        },
        {
          key: "_getAngleByArcLength",
          value: function _getAngleByArcLength(length, radius) {
            return (length * 180) / Math.PI / radius;
          } // EVENTS
        },
        {
          key: "_sectorOnClickHandler",
          value: function _sectorOnClickHandler(e) {
            location.href(e.element.link);
          }
        },
        {
          key: "_sectorHoverInHandler",
          value: function _sectorHoverInHandler(e) {
            var _this3 = this;

            var parent = this.parent();
            var elements = parent.children();

            if (elements.indexOf(this) !== elements.length - 1) {
              parent.append(this);
            }

            Snap.animate(
              1,
              1.2,
              function(val) {
                _this3.attr({
                  transform: "s".concat(val)
                });
              },
              150,
              mina.easein
            );
            this[0].attr({
              fill: "#8E44AD"
            });
            this[1].attr({
              fill: "#fff"
            });
            this[2].attr({
              fill: "#fff"
            });
          }
        },
        {
          key: "_sectorHoverOutHandler",
          value: function _sectorHoverOutHandler(e) {
            var _this4 = this;

            this.stop();
            Snap.animate(
              1.2,
              1,
              function(val) {
                _this4.attr({
                  transform: "s".concat(val)
                });
              },
              150,
              mina.easeout
            );
            this[0].attr({
              fill: "rgba(255,255,255,0.4)"
            });
            this[1].attr({
              fill: "#000"
            });
            this[2].attr({
              fill: "#000"
            });
          }
        },
        {
          key: "_circleHoverInHandler",
          value: function _circleHoverInHandler(e) {
            var _this5 = this;

            var parent = this.parent();
            var elements = parent.children();

            if (elements.indexOf(this) !== elements.length - 1) {
              parent.append(this);
            }

            Snap.animate(
              1,
              1.2,
              function(val) {
                _this5.attr({
                  transform: "s".concat(val)
                });
              },
              150,
              mina.easein
            );
          }
        },
        {
          key: "_circleHoverOutHandler",
          value: function _circleHoverOutHandler(e) {
            var _this6 = this;

            this.stop();
            Snap.animate(
              1.2,
              1,
              function(val) {
                _this6.attr({
                  transform: "s".concat(val)
                });
              },
              150,
              mina.easeout
            );
          }
        },
        {
          key: "_setEventHandlers",
          value: function _setEventHandlers() {
            var _this7 = this;

            window.addEventListener("resize", function(e) {
              _this7._updateSize();
            });
          }
        }
      ]);

      return Puzzle;
    })();

  var elements = [
    {
      title: ["Розничная", "торговля"],
      link: "/contabilizare-4-0/retail-trading/"
    },
    {
      title: ["Управленческий", "учет"],
      link: "/contabilizare-4-0/management-accounting/"
    },
    {
      title: ["Интернет", "торговля"],
      link: "/contabilizare-4-0/online-trading/"
    },
    {
      title: ["Управление", "продажами"],
      link: "/contabilizare-4-0/sales-management/"
    },
    {
      title: ["Финансовый", "учет"],
      link: "/contabilizare-4-0/financial-accounting/"
    },
    {
      title: ["Учет", "производства"],
      link: "/contabilizare-4-0/production-accounting/"
    }
  ];
  var puzzle = new Puzzle(Snap("#puzzle"), 570, 400, elements);
})();
